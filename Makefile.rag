# =====================================================
# Makefile para Sistema RAG - Datastores
# =====================================================

# Cargar variables de entorno
-include env.datastores
export

# =====================================================
# Comandos principales
# =====================================================

.PHONY: help up down ps init-db smoke clean logs

help: ## Mostrar ayuda
	@echo "Comandos disponibles para el sistema RAG:"
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}'

up: ## Levantar servicios de datastores
	@echo "ğŸš€ Levantando servicios de datastores..."
	docker compose up -d postgres qdrant redis
	@echo "â³ Esperando que los servicios estÃ©n listos..."
	@sleep 10
	@$(MAKE) ps

down: ## Detener servicios de datastores
	@echo "ğŸ›‘ Deteniendo servicios de datastores..."
	docker compose down

ps: ## Mostrar estado de servicios
	@echo "ğŸ“Š Estado de servicios:"
	docker compose ps

init-db: ## Inicializar base de datos PostgreSQL
	@echo "ğŸ—„ï¸  Inicializando base de datos PostgreSQL..."
	docker compose exec -T postgres psql -U "$(PGUSER)" -d "$(PGDATABASE)" -f scripts/init_rag.sql

smoke: ## Ejecutar smoke test de datastores
	@echo "ğŸ§ª Ejecutando smoke test de datastores..."
	./scripts/smoke-datastores.sh

clean: ## Limpiar volÃºmenes y datos
	@echo "ğŸ§¹ Limpiando volÃºmenes de datos..."
	docker compose down -v
	docker volume prune -f

logs: ## Mostrar logs de servicios
	@echo "ğŸ“‹ Logs de servicios:"
	docker compose logs -f

logs-postgres: ## Mostrar logs de PostgreSQL
	docker compose logs -f postgres

logs-qdrant: ## Mostrar logs de Qdrant
	docker compose logs -f qdrant

logs-redis: ## Mostrar logs de Redis
	docker compose logs -f redis

# =====================================================
# Comandos de desarrollo
# =====================================================

shell-postgres: ## Conectar a shell de PostgreSQL
	docker compose exec postgres psql -U "$(PGUSER)" -d "$(PGDATABASE)"

shell-redis: ## Conectar a shell de Redis
	docker compose exec redis redis-cli

status: ## Verificar estado detallado de servicios
	@echo "ğŸ“Š Estado detallado de servicios:"
	@echo ""
	@echo "PostgreSQL:"
	@docker compose exec -T postgres pg_isready -U "$(PGUSER)" || echo "âŒ No disponible"
	@echo ""
	@echo "Qdrant:"
	@curl -sf "$(QDRANT_URL)/readyz" && echo "âœ… Listo" || echo "âŒ No disponible"
	@echo ""
	@echo "Redis:"
	@docker compose exec -T redis redis-cli ping || echo "âŒ No disponible"

# =====================================================
# Comandos de prueba
# =====================================================

test-postgres: ## Probar PostgreSQL
	@echo "ğŸ§ª Probando PostgreSQL..."
	docker compose exec -T postgres psql -U "$(PGUSER)" -d "$(PGDATABASE)" -c "SELECT 'PostgreSQL funcionando' as status;"

test-qdrant: ## Probar Qdrant
	@echo "ğŸ§ª Probando Qdrant..."
	curl -s "$(QDRANT_URL)/collections" | jq

test-redis: ## Probar Redis
	@echo "ğŸ§ª Probando Redis..."
	docker compose exec -T redis redis-cli ping

# =====================================================
# Comandos de instalaciÃ³n
# =====================================================

install: ## InstalaciÃ³n completa del sistema RAG
	@echo "ğŸš€ InstalaciÃ³n completa del sistema RAG..."
	@$(MAKE) up
	@sleep 15
	@$(MAKE) init-db
	@$(MAKE) smoke
	@echo "âœ… InstalaciÃ³n completada"

# =====================================================
# Comandos de monitoreo
# =====================================================

monitor: ## Monitorear recursos de servicios
	@echo "ğŸ“Š Monitoreando recursos de servicios:"
	@echo ""
	@echo "PostgreSQL:"
	@docker stats --no-stream postgres-startkit-main-1 2>/dev/null || echo "No disponible"
	@echo ""
	@echo "Qdrant:"
	@docker stats --no-stream qdrant-startkit-main-1 2>/dev/null || echo "No disponible"
	@echo ""
	@echo "Redis:"
	@docker stats --no-stream redis-startkit-main-1 2>/dev/null || echo "No disponible"

# =====================================================
# Comandos de Seguridad y Operaciones
# =====================================================

# Purga segura (dry-run por defecto)
rag-reindex: ## ReindexaciÃ³n segura con dry-run por defecto
	@echo "ğŸ§¹ Ejecutando reindexaciÃ³n segura (dry-run)..."
	node rag/cli/rag-reindex.mjs

# Ejecutar purga real con guardas
rag-reindex-force: ## Ejecutar purga real con umbrales de seguridad
	@echo "âš ï¸  Ejecutando purga real con umbrales de seguridad..."
	@echo "Umbral: $(or $(RAG_PURGE_THRESHOLD),20)%"
	RAG_PURGE_THRESHOLD=$(or $(RAG_PURGE_THRESHOLD),20) node rag/cli/rag-reindex.mjs --force

# ValidaciÃ³n de contexto contra rÃ©plica/snapshot
rag-context-validate: ## Validar contexto contra rÃ©plica/snapshot
	@echo "ğŸ” Validando contexto contra rÃ©plica/snapshot..."
	PGREAD_HOST=$(or $(PGREAD_HOST),localhost) \
	PGREAD_USER=$(or $(PGREAD_USER),rag_read) \
	PGREAD_PASSWORD=$(or $(PGREAD_PASSWORD),rag_read_only) \
	PGREAD_DB=$(or $(PGREAD_DB),ragdb) \
	node scripts/gates/context-validate.mjs

# Actualizar PRP.lock (relaxed/ttl) y reportar STRICT
prp-lock-update: ## Actualizar PRP.lock y reportar cambios
	@echo "ğŸ”„ Actualizando PRP.lock..."
	node scripts/prp/prp-lock-update.mjs

# =====================================================
# Comandos Operacionales (Operations Playbook)
# =====================================================

eval.quick: ## RAGAS rÃ¡pido (20 queries)
	@echo "ğŸ§ª Ejecutando RAGAS quick (20 queries)..."
	python rag/eval/ragas_smoke.py --num_queries 20

eval.full: ## RAGAS completo (evalset)
	@echo "ğŸ§ª Ejecutando RAGAS completo..."
	python rag/eval/ragas_smoke.py --evalset rag/config/evalset.jsonl

perf.p95: ## Verificar latencia P95/P99
	@echo "ğŸ“Š Verificando latencia P95/P99..."
	python rag/eval/latency_smoke.py --p95 2500 --p99 4000

governance.check: ## Verificar gobernanza (owner, review_date)
	@echo "ğŸ” Verificando gobernanza..."
	node ops/gates/governance_check.mjs

context.validate: ## Validar contexto contra PRP.lock
	@echo "ğŸ” Validando contexto..."
	node ops/gates/context-validate.mjs

snapshot.create: ## Crear snapshots (Postgres + Qdrant)
	@echo "ğŸ“¸ Creando snapshots..."
	bash ops/snapshots/create_all.sh

snapshot.restore: ## Restaurar snapshots
	@echo "ğŸ”„ Restaurando snapshots..."
	bash ops/snapshots/restore_all.sh

traffic.%: ## Configurar trÃ¡fico canary (10, 25, 50, 100)
	@echo "ğŸš¦ Configurando trÃ¡fico canary a $*%..."
	node ops/traffic/set_canary.mjs --percent $*

rollback.auto: ## Rollback automÃ¡tico (disparado por alertas)
	@echo "ğŸš¨ Ejecutando rollback automÃ¡tico..."
	bash ops/runbooks/rollback_auto.sh

revert.last-green: ## Revertir a Ãºltima versiÃ³n estable
	@echo "âª Revirtiendo a Ãºltima versiÃ³n estable..."
	bash ops/runbooks/revert_last_green.sh

# =====================================================
# Comandos de ValidaciÃ³n Pre-Deploy
# =====================================================

pre-deploy: up smoke eval.quick perf.p95 governance.check context.validate snapshot.create ## Checklist completo pre-deploy
	@echo "âœ… Pre-deploy checklist completado"

# =====================================================
# Comandos de Emergencia (3 AM scenario)
# =====================================================

emergency.rollback: ## Rollback de emergencia completo
	@echo "ğŸš¨ ROLLBACK DE EMERGENCIA - 3 AM SCENARIO"
	@echo "1. Deteniendo trÃ¡fico..."
	@$(MAKE) traffic.0
	@echo "2. Rollback automÃ¡tico..."
	@$(MAKE) rollback.auto
	@echo "3. VerificaciÃ³n rÃ¡pida..."
	@$(MAKE) smoke
	@echo "4. NotificaciÃ³n enviada automÃ¡ticamente"

emergency.status: ## Estado de emergencia
	@echo "ğŸš¨ ESTADO DE EMERGENCIA - RAG Pipeline"
	@echo "=========================================="
	@echo "Servicios:"
	@$(MAKE) status
	@echo ""
	@echo "Gobernanza:"
	@$(MAKE) governance.check || echo "âŒ Gobernanza FAILED"
	@echo ""
	@echo "Contexto:"
	@$(MAKE) context.validate || echo "âŒ Contexto FAILED"
	@echo ""
	@echo "Ãšltimos snapshots disponibles:"
	@ls -la backups/rag_*.dump 2>/dev/null | tail -5 || echo "âŒ No snapshots found"
